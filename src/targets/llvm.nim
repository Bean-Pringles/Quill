import std/os
import fileWriter
import tables

proc llvmPre*(filename: string) =
    let file = splitFile(filename).name & ".ll"
    
    if fileExists(file):
        try:
            removeFile(file)
        except OSError as e:
            echo "Error deleting file: ", e.msg
    
    writeCode("; LLVM IR generated by Quill Compiler", file)

proc llvmPost*(filename: string, vars: Table[string, (string, string, int, bool)], entryCode: seq[string], globalDecls: seq[string], functionDefs: seq[string]) =
    let file = splitFile(filename).name & ".ll"

    # Write global declarations (string constants, function declarations)
    for i, decl in globalDecls:
        writeCode(decl, file)
    
    # Add blank line after global declarations
    if globalDecls.len > 0:
        writeCode("", file)
    
    # Write function definitions (print functions, etc.)
    for i, funcDef in functionDefs:
        writeCode(funcDef, file)
        # Add blank line between function definitions
        if i < functionDefs.len - 1:
            writeCode("", file)
    
    # Now write the _start function (custom entry point)
    writeCode("", file)
    writeCode("define i32 @_start() {", file)
    writeCode("entry:", file)
        
    # Add variable allocations and stores from let statements
    for varName, (varType, value, strLen, _) in vars.pairs():
        if varType == "ptr":
            # For string variables (pointers to global constants)
            writeCode("  %" & varName & " = alloca ptr, align 8", file)
            writeCode("  store ptr " & value & ", ptr %" & varName & ", align 8", file)
        else:
            # For numeric types
            let alignment = case varType
                of "i32", "float": "4"
                of "i64", "double": "8"
                of "i1": "1"
                else: "4"
                
            writeCode("  %" & varName & " = alloca " & varType & ", align " & alignment, file)
            writeCode("  store " & varType & " " & value & ", ptr %" & varName & ", align " & alignment, file)
        
    # Add all the entry code (assignments, function calls, etc.)
    for code in entryCode:
        writeCode(code, file)
        
    # Exit syscall for smallest binary (no libc exit)
    when defined(windows):
        writeCode("  ret i32 0", file)
    else:
        # Linux syscall exit(0) - smallest possible exit
        writeCode("  call void asm sideeffect \"movl $$60, %eax; xorl %edi, %edi; syscall\", \"~{dirflag},~{fpsr},~{flags}\"()", file)
        writeCode("  unreachable", file)
        
    writeCode("}", file)