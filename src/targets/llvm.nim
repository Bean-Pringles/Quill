import std/os
import fileWriter
import tables

proc llvmPre*(filename: string) =
    let file = splitFile(filename).name & ".ll"
    
    if fileExists(file):
        try:
            removeFile(file)
        except OSError as e:
            echo "Error deleting file: ", e.msg
    
    writeCode("; LLVM IR generated by Quill Compiler", file)

proc llvmPost*(filename: string, vars: Table[string, (string, string, int)], funcCalls: seq[string]) =
    let file = splitFile(filename).name & ".ll"

    # Now write the _start function (custom entry point)
    writeCode("", file)
    writeCode("define i32 @_start() {", file)
    writeCode("entry:", file)
        
    # Add variable allocations and stores from let statements
    for varName, (varType, value, strLen) in vars.pairs():
        if varType == "ptr":
            # For string variables (pointers to global constants)
            writeCode("  %" & varName & " = alloca ptr, align 8", file)
            writeCode("  store ptr " & value & ", ptr %" & varName & ", align 8", file)
        else:
            # For numeric types
            let alignment = case varType
                of "i32", "float": "4"
                of "i64", "double": "8"
                of "i1": "1"
                else: "4"
                
            writeCode("  %" & varName & " = alloca " & varType & ", align " & alignment, file)
            writeCode("  store " & varType & " " & value & ", ptr %" & varName & ", align " & alignment, file)
        
    # Add all the function calls
    for call in funcCalls:
        writeCode(call, file)
        
    # Exit syscall for smallest binary (no libc exit)
    when defined(windows):
        writeCode("  ret i32 0", file)
    else:
        # Linux syscall exit(0) - smallest possible exit
        writeCode("  call void asm sideeffect \"movl $$60, %eax; xorl %edi, %edi; syscall\", \"~{dirflag},~{fpsr},~{flags}\"()", file)
        writeCode("  unreachable", file)
        
    writeCode("}", file)